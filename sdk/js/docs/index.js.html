<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
  Backend JS SDK
  - Base URL: defaults to http://localhost:8080
  - Base Path: /api/v1
  - Auth: Authorization: Bearer &lt;access_token>
  - Auto refresh access token on 401 using /users/refresh (optional)
*/

const DEFAULT_BASE_URL = 'http://localhost:8080';
const DEFAULT_BASE_PATH = '/api/v1';

/**
 * Backend API Error
 * @extends Error
 * @property {number|undefined} status - HTTP status code
 * @property {number|string|undefined} code - Business error code from server
 * @property {any} payload - Raw parsed response body
 */
class BackendApiError extends Error {
  constructor(message, { status, code, payload }) {
    super(message || 'Backend API Error');
    this.name = 'BackendApiError';
    this.status = status;
    this.code = code;
    this.payload = payload;
  }
}

function isNullish(v) {
  return v === undefined || v === null;
}

function buildURL(baseURL, basePath, path, query) {
  const url = new URL(String(baseURL).replace(/\/$/, '') + String(basePath) + path);
  if (query &amp;&amp; typeof query === 'object') {
    Object.entries(query).forEach(([k, v]) => {
      if (!isNullish(v)) {
        url.searchParams.append(k, String(v));
      }
    });
  }
  return url.toString();
}

function ensureFetch(fetchImpl) {
  if (fetchImpl) return fetchImpl;
  if (typeof fetch !== 'undefined') return fetch;
  if (typeof globalThis !== 'undefined' &amp;&amp; globalThis.fetch) return globalThis.fetch;
  throw new Error('No fetch implementation found. Provide options.fetch.');
}

/**
 * @typedef {Object} ClientOptions
 * @property {string} [baseURL] - API base URL, default `http://localhost:8080`
 * @property {string} [basePath] - API base path, default `/api/v1`
 * @property {string} [accessToken] - Initial access token
 * @property {string} [refreshToken] - Initial refresh token
 * @property {boolean} [autoRefresh=true] - Auto refresh on 401 with `/users/refresh`
 * @property {typeof fetch} [fetch] - Custom fetch implementation
 * @property {Record&lt;string,string>} [defaultHeaders] - Default headers for all requests
 */
/**
 * 创建 JS SDK 客户端
 *
 * 返回的客户端对象包含：`files`、`users`、`auth`、`friends`、`chat` 等域方法；
 * 以及令牌控制 `setTokens/getTokens/clearTokens`。
 *
 * @param {ClientOptions} [options]
 * @returns {{
 *   baseURL: string,
 *   basePath: string,
 *   setTokens: (tokens:{accessToken?:string,refreshToken?:string})=>void,
 *   clearTokens: ()=>void,
 *   getTokens: ()=>{accessToken?:string,refreshToken?:string},
 *   _request: Function,
 *   _refreshAccessToken: Function,
 *   BackendApiError: typeof BackendApiError,
 *   generateDeviceFingerprint: ()=>string,
 *   getDeviceName: ()=>string,
 *   getDeviceType: ()=>('mobile'|'tablet'|'desktop'),
 *   files: object,
 *   users: object,
 *   auth: object,
 *   friends: object,
 *   chat: { connect: (opts?:{token?:string,onOpen?:Function,onClose?:Function,onError?:Function,onMessage?:(data:any)=>void})=>{socket:WebSocket, send:Function, close:Function} }
 * }}
 */
function createClient(options = {}) {
  const {
    baseURL = DEFAULT_BASE_URL,
    basePath = DEFAULT_BASE_PATH,
    accessToken: initialAccessToken,
    refreshToken: initialRefreshToken,
    autoRefresh = true,
    fetch: fetchImpl,
    defaultHeaders = {},
  } = options;

  const $fetch = ensureFetch(fetchImpl);

  const state = {
    accessToken: initialAccessToken || undefined,
    refreshToken: initialRefreshToken || undefined,
    isRefreshing: false,
  };

  // Friends APIs (user-side)
  /**
   * 好友相关 API
   *
   * - POST /friends/requests, /friends/requests/{id}/accept, /reject, DELETE /friends/requests/{id}
   * - GET /friends/list
   * - GET /friends/requests/incoming, /friends/requests/outgoing
   * - PATCH /friends/remarks/{friend_id}
   * - DELETE /friends/{friend_id}
   * - POST /friends/blocks/{user_id}, DELETE /friends/blocks/{user_id}, GET /friends/blocks
   */
  const friends = {
    /** 创建好友请求（POST /friends/requests，需鉴权） */
    createRequest: ({ receiver_id, note } = {}) =>
      doRequest('POST', '/friends/requests', { auth: true, body: { receiver_id, note } }),
    /** 接受好友请求（POST /friends/requests/{id}/accept，需鉴权） */
    acceptRequest: (id) =>
      doRequest('POST', `/friends/requests/${encodeURIComponent(id)}/accept`, { auth: true }),
    /** 拒绝好友请求（POST /friends/requests/{id}/reject，需鉴权） */
    rejectRequest: (id) =>
      doRequest('POST', `/friends/requests/${encodeURIComponent(id)}/reject`, { auth: true }),
    /** 取消我发出的好友请求（DELETE /friends/requests/{id}，需鉴权） */
    cancelRequest: (id) =>
      doRequest('DELETE', `/friends/requests/${encodeURIComponent(id)}`, { auth: true }),

    /** 获取好友列表（GET /friends/list，支持分页与搜索，需鉴权） */
    listFriends: ({ page, limit, search } = {}) =>
      doRequest('GET', '/friends/list', { auth: true, query: { page, limit, search } }),
    /** 获取收到的好友请求（GET /friends/requests/incoming，支持按状态筛选，需鉴权） */
    listIncoming: ({ page, limit, status } = {}) =>
      doRequest('GET', '/friends/requests/incoming', { auth: true, query: { page, limit, status } }),
    /** 获取发出的好友请求（GET /friends/requests/outgoing，支持按状态筛选，需鉴权） */
    listOutgoing: ({ page, limit, status } = {}) =>
      doRequest('GET', '/friends/requests/outgoing', { auth: true, query: { page, limit, status } }),

    /** 更新好友备注（PATCH /friends/remarks/{friend_id}，需鉴权） */
    updateRemark: (friend_id, remark) =>
      doRequest('PATCH', `/friends/remarks/${encodeURIComponent(friend_id)}`, { auth: true, body: { remark } }),
    /** 删除好友（DELETE /friends/{friend_id}，需鉴权） */
    deleteFriend: (friend_id) =>
      doRequest('DELETE', `/friends/${encodeURIComponent(friend_id)}`, { auth: true }),

    /** 加入黑名单（POST /friends/blocks/{user_id}，需鉴权） */
    block: (user_id) =>
      doRequest('POST', `/friends/blocks/${encodeURIComponent(user_id)}`, { auth: true }),
    /** 取消黑名单（DELETE /friends/blocks/{user_id}，需鉴权） */
    unblock: (user_id) =>
      doRequest('DELETE', `/friends/blocks/${encodeURIComponent(user_id)}`, { auth: true }),
    /** 黑名单列表（GET /friends/blocks，支持分页，需鉴权） */
    listBlocks: ({ page, limit } = {}) =>
      doRequest('GET', '/friends/blocks', { auth: true, query: { page, limit } }),
  };

  /**
   * 统一解包响应：优先解析 JSON，自动解包 `{ data: ... }` 结构；非 2xx 则抛出 `BackendApiError`。
   * @param {Response} resp
   * @returns {Promise&lt;any>}
   * @throws {BackendApiError}
   */
  async function unwrapResponse(resp) {
    let data;
    const text = await resp.text();
    try {
      data = text ? JSON.parse(text) : null;
    } catch (e) {
      // not JSON
      data = text;
    }

    if (!resp.ok) {
      const message = data &amp;&amp; data.message ? data.message : `HTTP ${resp.status}`;
      const code = data &amp;&amp; typeof data.code !== 'undefined' ? data.code : undefined;
      throw new BackendApiError(message, { status: resp.status, code, payload: data });
    }

    if (data &amp;&amp; typeof data === 'object' &amp;&amp; Object.prototype.hasOwnProperty.call(data, 'data')) {
      return data.data;
    }
    return data;
  }

  /**
   * 统一请求封装（自动附加 Authorization，401 自动刷新一次 AccessToken 后重试）
   * @param {string} method - HTTP 方法，如 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
   * @param {string} path - 以 basePath 为前缀的路径，如 '/users/me'
   * @param {{query?:object, body?:any, auth?:boolean, headers?:Record&lt;string,string>, isForm?:boolean}} [options]
   * @param {boolean} [retryOn401=true]
   * @returns {Promise&lt;any>}
   */
  async function doRequest(method, path, { query, body, auth = false, headers, isForm = false } = {}, retryOn401 = true) {
    const url = buildURL(baseURL, basePath, path, query);

    const reqHeaders = { ...defaultHeaders, ...(headers || {}) };

    if (auth &amp;&amp; state.accessToken) {
      reqHeaders['Authorization'] = `Bearer ${state.accessToken}`; // middleware expects Bearer (case-insensitive)
    }

    const init = { method, headers: reqHeaders };

    if (!isForm &amp;&amp; body &amp;&amp; typeof body === 'object') {
      reqHeaders['Content-Type'] = 'application/json';
      init.body = JSON.stringify(body);
    } else if (isForm &amp;&amp; body) {
      // do not set Content-Type, let browser/node set boundary automatically
      init.body = body;
    }

    const resp = await $fetch(url, init);

    if (resp.status === 401 &amp;&amp; auth &amp;&amp; autoRefresh &amp;&amp; state.refreshToken &amp;&amp; retryOn401) {
      // try refresh once
      try {
        await refreshAccessToken();
      } catch (_) {
        // refresh failed; fall through to throw original 401
        // but prefer unwrap of original response for consistent error
        return unwrapResponse(resp);
      }
      return doRequest(method, path, { query, body, auth, headers, isForm }, false);
    }

    return unwrapResponse(resp);
  }

  /**
   * 使用 refresh_token 刷新 access_token（POST /users/refresh）
   * @returns {Promise&lt;string>} 新的 access_token
   */
  async function refreshAccessToken() {
    if (!state.refreshToken) throw new Error('Missing refreshToken');
    if (state.isRefreshing) throw new Error('Refresh already in progress');
    state.isRefreshing = true;
    try {
      const data = await doRequest('POST', '/users/refresh', {
        body: { refresh_token: state.refreshToken },
        auth: false,
      }, false);
      if (!data || !data.access_token) throw new Error('Invalid refresh response');
      state.accessToken = data.access_token;
      return state.accessToken;
    } finally {
      state.isRefreshing = false;
    }
  }

  /**
   * 设置本地令牌
   * @param {{accessToken?:string, refreshToken?:string}} tokens
   */
  function setTokens({ accessToken, refreshToken } = {}) {
    if (!isNullish(accessToken)) state.accessToken = accessToken || undefined;
    if (!isNullish(refreshToken)) state.refreshToken = refreshToken || undefined;
  }

  /** 清空本地令牌 */
  function clearTokens() {
    state.accessToken = undefined;
    state.refreshToken = undefined;
  }

  /** 获取当前本地令牌 */
  function getTokens() {
    return { accessToken: state.accessToken, refreshToken: state.refreshToken };
  }

  // Files APIs
  /**
   * 文件相关 API
   *
   * - GET /files/{id}
   * - PUT /files/{id}
   * - DELETE /files/{id}
   * - GET /files/my
   * - GET /files/public
   * - GET /files/storages
   * - POST /files/upload
   * - POST /files/upload-multiple
   */
  const files = {
    /**
     * 获取文件信息（可选鉴权，用于访问私有文件时携带 Bearer Token）
     * @param {string} id
     * @param {{auth?:boolean}} [options]
     * @returns {Promise&lt;any>} 响应对象（自动解包 data 字段）
     * @example
     * const sdk = createClient({ accessToken, refreshToken });
     * await sdk.files.getFile('file-id', { auth: true });
     */
    getFile: (id, { auth = false } = {}) =>
      doRequest('GET', `/files/${encodeURIComponent(id)}`, { auth }),
    /** 更新文件信息（PUT /files/{id}，需要鉴权） */
    updateFile: (id, payload) => doRequest('PUT', `/files/${encodeURIComponent(id)}`, { auth: true, body: payload }),
    /** 删除文件（DELETE /files/{id}，需要鉴权） */
    deleteFile: (id) => doRequest('DELETE', `/files/${encodeURIComponent(id)}`, { auth: true }),
    /** 获取我的文件列表（GET /files/my，需鉴权） */
    listMyFiles: (query) => doRequest('GET', '/files/my', { auth: true, query }),
    /** 获取公开文件列表（GET /files/public） */
    listPublicFiles: (query) => doRequest('GET', '/files/public', { query }),
    /** 获取可用存储（GET /files/storages） */
    getStorages: () => doRequest('GET', '/files/storages'),
    /** 上传单个文件（POST /files/upload，需鉴权；表单上传） */
    upload: ({ file, storage_name, category, description, is_public } = {}) => {
      if (!file) throw new Error('file is required');
      const fd = new FormData();
      fd.append('file', file);
      if (!isNullish(storage_name)) fd.append('storage_name', String(storage_name));
      if (!isNullish(category)) fd.append('category', String(category));
      if (!isNullish(description)) fd.append('description', String(description));
      if (!isNullish(is_public)) fd.append('is_public', String(is_public));
      return doRequest('POST', '/files/upload', { auth: true, isForm: true, body: fd });
    },
    /** 批量上传文件（POST /files/upload-multiple，需鉴权；表单上传） */
    uploadMultiple: ({ files, storage_name, category, description, is_public } = {}) => {
      if (!files || !Array.isArray(files) || files.length === 0) throw new Error('files is required (non-empty array)');
      const fd = new FormData();
      for (const f of files) fd.append('files', f);
      if (!isNullish(storage_name)) fd.append('storage_name', String(storage_name));
      if (!isNullish(category)) fd.append('category', String(category));
      if (!isNullish(description)) fd.append('description', String(description));
      if (!isNullish(is_public)) fd.append('is_public', String(is_public));
      return doRequest('POST', '/files/upload-multiple', { auth: true, isForm: true, body: fd });
    },
  };

  // Device fingerprint generation utility
  /**
   * 生成设备指纹（浏览器端）
   * @returns {string} 简单哈希（16 进制）
   */
  function generateDeviceFingerprint() {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    ctx.textBaseline = 'top';
    ctx.font = '14px Arial';
    ctx.fillText('Device fingerprint', 2, 2);
    
    const fingerprint = [
      navigator.userAgent,
      navigator.language,
      screen.width + 'x' + screen.height,
      screen.colorDepth,
      new Date().getTimezoneOffset(),
      navigator.platform,
      navigator.cookieEnabled,
      canvas.toDataURL(),
    ].join('|');
    
    // Simple hash function (for demo purposes)
    let hash = 0;
    for (let i = 0; i &lt; fingerprint.length; i++) {
      const char = fingerprint.charCodeAt(i);
      hash = ((hash &lt;&lt; 5) - hash) + char;
      hash = hash &amp; hash; // Convert to 32-bit integer
    }
    return Math.abs(hash).toString(16).padStart(8, '0');
  }

  /**
   * 获取设备名称（粗略判断 UA）
   * @returns {string}
   */
  function getDeviceName() {
    const ua = navigator.userAgent;
    if (/iPhone/i.test(ua)) return 'iPhone';
    if (/iPad/i.test(ua)) return 'iPad';
    if (/Android/i.test(ua)) return 'Android设备';
    if (/Windows/i.test(ua)) return 'Windows电脑';
    if (/Mac/i.test(ua)) return 'Mac电脑';
    if (/Linux/i.test(ua)) return 'Linux设备';
    return '未知设备';
  }

  /**
   * 获取设备类型（mobile/tablet/desktop）
   * @returns {'mobile'|'tablet'|'desktop'}
   */
  function getDeviceType() {
    const ua = navigator.userAgent;
    if (/Mobile|Android|iPhone/i.test(ua)) return 'mobile';
    if (/iPad|Tablet/i.test(ua)) return 'tablet';
    return 'desktop';
  }

  // Users &amp; Auth APIs
  /**
   * 用户相关 API
   * - GET /users/{id}
   * - GET /users/username/{username}
   * - GET/PUT /users/me
   * - POST /users/register, /users/send-code, /users/send-reset-code, /users/reset-password
   * - POST /users/send-activation-code, /users/activate
   */
  const users = {
    /** 根据ID获取用户（GET /users/{id}） */
    getById: (id) => doRequest('GET', `/users/${encodeURIComponent(id)}`),
    /** 根据用户名获取用户（GET /users/username/{username}） */
    getByUsername: (username) => doRequest('GET', `/users/username/${encodeURIComponent(username)}`),
    /** 获取当前用户（GET /users/me，需鉴权） */
    me: () => doRequest('GET', '/users/me', { auth: true }),
    /** 更新当前用户（PUT /users/me，需鉴权） */
    updateMe: (payload) => doRequest('PUT', '/users/me', { auth: true, body: payload }),
    /** 注册（POST /users/register） */
    register: (payload) => doRequest('POST', '/users/register', { body: payload }),
    /** 发送注册验证码（POST /users/send-code） */
    sendCode: (payload) => doRequest('POST', '/users/send-code', { body: payload }),
    /** 发送重置密码验证码（POST /users/send-reset-code） */
    sendResetCode: (payload) => doRequest('POST', '/users/send-reset-code', { body: payload }),
    /** 重置密码（POST /users/reset-password） */
    resetPassword: (payload) => doRequest('POST', '/users/reset-password', { body: payload }),
    /** 发送激活码（POST /users/send-activation-code） */
    sendActivationCode: (payload) => doRequest('POST', '/users/send-activation-code', { body: payload }),
    /** 激活账号（POST /users/activate） */
    activateAccount: (payload) => doRequest('POST', '/users/activate', { body: payload }),
  };

  /**
   * 认证相关 API
   * - POST /users/login
   * - POST /users/logout
   * - POST /users/refresh
   */
  const auth = {
    /**
     * 传统登录（不带设备验证）
     * @param {{username:string,password:string}} payload
     * @returns {Promise&lt;{access_token?:string, refresh_token?:string, user?:any, verification_required?:boolean}>}
     */
    login: async (payload) => {
      const data = await doRequest('POST', '/users/login', { body: payload });
      // data: { access_token, refresh_token, user } or { user, verification_required: true }
      if (data &amp;&amp; data.access_token) state.accessToken = data.access_token;
      if (data &amp;&amp; data.refresh_token) state.refreshToken = data.refresh_token;
      return data;
    },
    
    /**
     * 设备登录验证（自动生成设备指纹）
     * @param {{username:string,password:string, deviceVerifyCode?:string, customDeviceId?:string, customDeviceName?:string, customDeviceType?:string}} [params]
     * @returns {Promise&lt;{access_token?:string, refresh_token?:string, user?:any, verification_required?:boolean}>}
     */
    loginWithDevice: async ({ username, password, deviceVerifyCode, customDeviceId, customDeviceName, customDeviceType } = {}) => {
      const payload = {
        username,
        password,
        device_id: customDeviceId || generateDeviceFingerprint(),
        device_name: customDeviceName || getDeviceName(),
        device_type: customDeviceType || getDeviceType(),
      };
      
      if (deviceVerifyCode) {
        payload.device_verification_code = deviceVerifyCode;
      }
      
      const data = await doRequest('POST', '/users/login', { body: payload });
      
      // 如果返回了 token，说明登录成功
      if (data &amp;&amp; data.access_token) {
        state.accessToken = data.access_token;
        state.refreshToken = data.refresh_token;
      }
      
      return data;
    },
    
    /**
     * 手动设备登录（完全自定义参数）
     * @param {object} payload - 直接将 payload 发送给 POST /users/login
     * @returns {Promise&lt;{access_token?:string, refresh_token?:string, user?:any, verification_required?:boolean}>}
     */
    loginWithCustomDevice: async (payload) => {
      const data = await doRequest('POST', '/users/login', { body: payload });
      if (data &amp;&amp; data.access_token) state.accessToken = data.access_token;
      if (data &amp;&amp; data.refresh_token) state.refreshToken = data.refresh_token;
      return data;
    },
    
    /**
     * 登出（POST /users/logout）。如果未提供 payload，则尝试使用当前本地的 access_token 与 refresh_token。
     * @param {{access_token:string, refresh_token:string}} [payload]
     * @returns {Promise&lt;any>}
     */
    logout: async (payload) => {
      const actualPayload = payload || (state.accessToken &amp;&amp; state.refreshToken ? { access_token: state.accessToken, refresh_token: state.refreshToken } : undefined);
      if (!actualPayload) throw new Error('logout requires { access_token, refresh_token }');
      const res = await doRequest('POST', '/users/logout', { body: actualPayload });
      // clear local tokens regardless of server response success
      clearTokens();
      return res;
    },
    /**
     * 刷新 Access Token（POST /users/refresh）。
     * 若未提供 payload，则尝试使用当前本地 refresh_token。
     * @param {{refresh_token:string}} [payload]
     * @returns {Promise&lt;{access_token?:string}>}
     */
    refresh: async (payload) => {
      const actualPayload = payload || (state.refreshToken ? { refresh_token: state.refreshToken } : undefined);
      if (!actualPayload) throw new Error('refresh requires { refresh_token }');
      const data = await doRequest('POST', '/users/refresh', { body: actualPayload });
      if (data &amp;&amp; data.access_token) state.accessToken = data.access_token;
      return data;
    },
  };

  return {
    // config
    baseURL,
    basePath,

    // token controls
    setTokens,
    clearTokens,
    getTokens,

    // raw helpers
    _request: doRequest,
    _refreshAccessToken: refreshAccessToken,

    // device utilities
    generateDeviceFingerprint,
    getDeviceName,
    getDeviceType,

    // error class
    BackendApiError,

    // domain APIs
    files,
    users,
    auth,
    friends,
    // Chat WS module
    chat: (() => {
      function buildWSURL(baseURL, basePath, token) {
        const httpUrl = String(baseURL).replace(/\/$/, '') + String(basePath) + '/ws/chat';
        const u = new URL(httpUrl);
        const wsProto = u.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = wsProto + '//' + u.host + u.pathname + (token ? `?token=${encodeURIComponent(token)}` : '');
        return wsUrl;
      }

      /**
       * 建立聊天 WebSocket 连接（/ws/chat?token=...）
       * @param {{token?:string,onOpen?:Function,onClose?:Function,onError?:Function,onMessage?:(data:any)=>void}} [params]
       * @returns {{socket: WebSocket, send: ({to_user_id?:string,room_id?:string,content:string})=>void, close: ()=>void}}
       * @example
       * const { socket, send, close } = sdk.chat.connect({ onMessage: console.log });
       * send({ to_user_id: 'uid', content: 'hello' });
       */
      function connect({ token, onOpen, onClose, onError, onMessage } = {}) {
        const tk = token || state.accessToken;
        const url = buildWSURL(baseURL, basePath, tk);
        const ws = new WebSocket(url);
        if (onOpen) ws.addEventListener('open', onOpen);
        if (onClose) ws.addEventListener('close', onClose);
        if (onError) ws.addEventListener('error', onError);
        if (onMessage) ws.addEventListener('message', (ev) => {
          try {
            const data = ev.data ? JSON.parse(ev.data) : null;
            onMessage(data);
          } catch (_) {
            onMessage(ev.data);
          }
        });
        function send({ to_user_id, room_id, content }) {
          if (!content) throw new Error('content is required');
          const payload = { content };
          if (room_id) payload.room_id = room_id;
          else if (to_user_id) payload.to_user_id = to_user_id;
          else throw new Error('either room_id or to_user_id is required');
          ws.send(JSON.stringify(payload));
        }
        function close() { try { ws.close(); } catch (_) {} }
        return { socket: ws, send, close };
      }

      return { connect };
    })(),
  };
}

export default createClient;
export { createClient, BackendApiError };
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="BackendApiError.html">BackendApiError</a></li></ul><h3>Global</h3><ul><li><a href="global.html#createClient">createClient</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Sat Aug 23 2025 03:40:12 GMT+0800 (Malaysia Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
